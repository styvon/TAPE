# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Get score within a variance component estimation iteration
#'
#' @title Get score value in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param densekin 	list of dense covariance matrices read from kmatfile.
#' @param W 			numeric vector.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param is_AI        boolean. Whether AI trace estimation will be used.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A list with following elements:
#' * YPAPY
#' * Trace
#' * PY
#' * AI
#' * cov = XSiX_inv
#' * tau
#' * alpha
#' * dtau
#' * eta
#' * XSiX_inv_SiXt
getScore <- function(n_nomissing, q, Y, X, sparsekin, densekin, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_getScore', PACKAGE = 'TAPE', n_nomissing, q, Y, X, sparsekin, densekin, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Variance component estimation
#'
#' @title Iteratively estimate variance components tau in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param K 			matrix of kinship coefficients (sparse).
#' @param kmatfile 	string vector, path to covariance matrices.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param Y			column vector, working y
#' @param y			column vector, original y
#' @param X   			data matrix
#' @param W 			numeric vector.
#' @param alpha 		numeric vector.
#' @param maxiter 		integer, maximum iteration.
#' @param tol         	Numeric. Tolerance for estimation of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm. 
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm. 
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @param verbose		boolean. 
#' @param tol_tau		Numeric. Threshold for minimum variance components. Default is 1e-5.
#' @return A List.
#' * theta: variance components estimates
#' * coefficients
#' * linear_predictors
#' * fitted_values
#' * Y
#' * X
#' * residuals
#' * cov
#' * converged
#' * method
getTau <- function(n_nomissing, sparsekin, kmatfile, tau, fixtau, Y, y, X, alpha, W, maxiter, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace, verbose, tol_tau = 1e-5) {
    .Call('_TAPE_getTau', PACKAGE = 'TAPE', n_nomissing, sparsekin, kmatfile, tau, fixtau, Y, y, X, alpha, W, maxiter, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace, verbose, tol_tau)
}

#' Variance component estimation
#' Uses Plink file for GRM construction
#'
#' @title Iteratively estimate variance components tau in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param Y			column vector, working y
#' @param y			column vector, original y
#' @param X   			data matrix
#' @param W 			numeric vector.
#' @param alpha 		numeric vector.
#' @param maxiter 		integer, maximum iteration.
#' @param tol         	Numeric. Tolerance for convergence of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm. 
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm. 
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @param verbose		boolean. 
#' @param loco 		boolean. Indicator for leave-one-chromosome-out analysis.
#' @param startid_chr_LOCO integer vector. Indeces for starting point for 22 chromosomes.
#' @param endid_chr_LOCO 	integer vector. Indeces for ending point for 22 chromosomes.
#' @param tol_tau		Numeric. Threshold for minimum variance components value. Default is 1e-5.
#' @param tol_coef    Numeric. Tolerance for convergence of coefficients. Default is 0.1
#' @return A List.
#' * theta: variance components estimates
#' * coefficients
#' * linear_predictors
#' * fitted_values
#' * Y
#' * X
#' * residuals
#' * cov
#' * XSiX_inv_SiXt
#' * converged
#' * method
#' * LOCO
#' * result_LOCO (if LOCO=TRUE)
getTau_plink <- function(n_nomissing, sparsekin, tau, fixtau, Y, y, X, alpha, W, maxiter, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace, verbose, loco, startid_chr_LOCO, endid_chr_LOCO, tol_tau = 1e-5, tol_coef = 0.1) {
    .Call('_TAPE_getTau_plink', PACKAGE = 'TAPE', n_nomissing, sparsekin, tau, fixtau, Y, y, X, alpha, W, maxiter, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace, verbose, loco, startid_chr_LOCO, endid_chr_LOCO, tol_tau, tol_coef)
}

#' Variance component estimation
#' Uses Plink file for GRM construction and no sparse kinship matrix
#'
#' @title Iteratively estimate variance components tau in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param Y			column vector, working y
#' @param y			column vector, original y
#' @param X   			data matrix
#' @param W 			numeric vector.
#' @param alpha 		numeric vector.
#' @param maxiter 		integer, maximum iteration.
#' @param tol         	Numeric. Tolerance for estimation of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm. 
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm. 
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @param verbose		boolean. 
#' @param tol_tau		Numeric. Threshold for minimum variance components value. Default is 1e-5.
#' @param tol_coef    Numeric. Tolerance for convergence of coefficients. Default is 0.1
#' @return A List.
#' * theta: variance components estimates
#' * coefficients
#' * linear_predictors
#' * fitted_values
#' * Y
#' * X
#' * residuals
#' * cov
#' * XSiX_inv_SiXt
#' * converged
#' * method
getTau_plink_nok <- function(n_nomissing, tau, fixtau, Y, y, X, alpha, W, maxiter, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace, verbose, tol_tau = 1e-5, tol_coef = 0.1) {
    .Call('_TAPE_getTau_plink_nok', PACKAGE = 'TAPE', n_nomissing, tau, fixtau, Y, y, X, alpha, W, maxiter, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace, verbose, tol_tau, tol_coef)
}

#' Get trace using Hutchinson’s randomized trace estimator
#' @param n_nomissing  integer
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param densekin 	list of dense covariance matrices read from kmatfile.
#' @param Sigma 		matrix
#' @param Sigma_iX 	matrix
#' @param X 			matrix
#' @param W_vec 		vector of type arma::fvec.
#' @param XSiX_inv 	matrix, covariance
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
getTrace <- function(n_nomissing, q, sparsekin, densekin, Sigma, Sigma_iX, X, W_vec, XSiX_inv, nrun_trace, maxiter_pcg, tol_pcg, cutoff_trace) {
    .Call('_TAPE_getTrace', PACKAGE = 'TAPE', n_nomissing, q, sparsekin, densekin, Sigma, Sigma_iX, X, W_vec, XSiX_inv, nrun_trace, maxiter_pcg, tol_pcg, cutoff_trace)
}

#' Variance component update per iteration
#'
#' @title Update variance components tau in GLMM once
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param W 			numeric vector.
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param densekin 	list of dense covariance matrices read from kmatfile.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param tol         	Numeric. Tolerance for estimation of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A List with the following elements:
#' * tau
#' * cov = XSiX_inv
#' * alpha
#' * eta
glmmaiUpdate <- function(n_nomissing, q, Y, X, W, sparsekin, densekin, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_glmmaiUpdate', PACKAGE = 'TAPE', n_nomissing, q, Y, X, W, sparsekin, densekin, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Variance component update per iteration
#'
#' @title Update variance components tau in GLMM once
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param W 			numeric vector.
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param tol         	Numeric. Tolerance for minimum of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A List with the following elements:
#' * tau
#' * cov = XSiX_inv
#' * XSiX_inv_SiXt
#' * alpha
#' * eta
#' * Sigma_iX
glmmaiUpdate_plink <- function(n_nomissing, q, Y, X, W, sparsekin, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_glmmaiUpdate_plink', PACKAGE = 'TAPE', n_nomissing, q, Y, X, W, sparsekin, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Variance component update per iteration
#' without sparse kinship matrix
#'
#' @title Update variance components tau in GLMM once
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param W 			numeric vector.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param tol         	Numeric. Tolerance for estimation of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A List with the following elements:
#' * tau
#' * cov = XSiX_inv
#' * XSiX_inv_SiXt
#' * alpha
#' * eta
#' * Sigma_iX
glmmaiUpdate_plink_nok <- function(n_nomissing, q, Y, X, W, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_glmmaiUpdate_plink_nok', PACKAGE = 'TAPE', n_nomissing, q, Y, X, W, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Variance component update per iteration (LOCO)
#'
#' @title Update variance components tau in GLMM once
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param W 			numeric vector.
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param tol         	Numeric. Tolerance for estimation of variance components.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A List with the following elements:
#' * tau
#' * cov = XSiX_inv
#' * XSiX_inv_SiXt
#' * alpha
#' * eta
#' * Sigma_iX
glmmaiUpdate_plink_LOCO <- function(n_nomissing, q, Y, X, W, sparsekin, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_glmmaiUpdate_plink_LOCO', PACKAGE = 'TAPE', n_nomissing, q, Y, X, W, sparsekin, tau, fixtau, tol, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

setgeno <- function(genofile, subSampleInGeno, memoryChunk, isDiagofKinSetAsOne) {
    .Call('_TAPE_setgeno', PACKAGE = 'TAPE', genofile, subSampleInGeno, memoryChunk, isDiagofKinSetAsOne)
}

setgeno_fast <- function(genofile, subSampleInGeno, memoryChunk) {
    .Call('_TAPE_setgeno_fast', PACKAGE = 'TAPE', genofile, subSampleInGeno, memoryChunk)
}

closegeno <- function() {
    invisible(.Call('_TAPE_closegeno', PACKAGE = 'TAPE'))
}

setLOCOid <- function(startid_LOCO, endid_LOCO) {
    invisible(.Call('_TAPE_setLOCOid', PACKAGE = 'TAPE', startid_LOCO, endid_LOCO))
}

getNnomissingR <- function() {
    .Call('_TAPE_getNnomissingR', PACKAGE = 'TAPE')
}

getMACR <- function(m) {
    .Call('_TAPE_getMACR', PACKAGE = 'TAPE', m)
}

getMAFR <- function() {
    .Call('_TAPE_getMAFR', PACKAGE = 'TAPE')
}

getDiagGRM <- function() {
    .Call('_TAPE_getDiagGRM', PACKAGE = 'TAPE')
}

getDiagGRM_LOCO <- function() {
    .Call('_TAPE_getDiagGRM_LOCO', PACKAGE = 'TAPE')
}

#' Get diagonal elements from Sigma
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' 
#' @param sparsekin  matrix of kinship coefficients (sparse).
#' @param W        numeric vector.
#' @param tau      numeric vector, initial values for variance components.
#' @return A vector with diagonal elements of Sigma
getDiagOfSigma <- function(sparsekin, W, tau) {
    .Call('_TAPE_getDiagOfSigma', PACKAGE = 'TAPE', sparsekin, W, tau)
}

#' Get diagonal elements from Sigma (LOCO)
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' 
#' @param sparsekin  matrix of kinship coefficients (sparse).
#' @param W        numeric vector.
#' @param tau      numeric vector, initial values for variance components.
#' @return A vector with diagonal elements of Sigma
getDiagOfSigma_LOCO <- function(sparsekin, W, tau) {
    .Call('_TAPE_getDiagOfSigma_LOCO', PACKAGE = 'TAPE', sparsekin, W, tau)
}

#' Get diagonal elements from Sigma
#' without sparse kinship matrix
#' Sigma = tau[0] * diag(1/W) + tau[2] * grm 
#' 
#' @param W        numeric vector.
#' @param tau      numeric vector, initial values for variance components.
#' @return A vector with diagonal elements of Sigma
getDiagOfSigma_nok <- function(W, tau) {
    .Call('_TAPE_getDiagOfSigma_nok', PACKAGE = 'TAPE', W, tau)
}

#' Get mean of diagonal elements from Genetic relationship matrix
getMeanDiagOfGRM <- function() {
    .Call('_TAPE_getMeanDiagOfGRM', PACKAGE = 'TAPE')
}

#' Get product of GRM and vector parallel worker
#' 
#' @param bVec       numeric vector, used for product
#' @return vector
parallelCrossProdGRM <- function(bVec) {
    .Call('_TAPE_parallelCrossProdGRM', PACKAGE = 'TAPE', bVec)
}

#' Get product of GRM and vector parallel worker (LOCO)
#' 
#' @param bVec       numeric vector, used for product
#' @return vector
parallelCrossProdGRM_LOCO <- function(bVec) {
    .Call('_TAPE_parallelCrossProdGRM_LOCO', PACKAGE = 'TAPE', bVec)
}

#' Get product of GRM and vector
#' 
#' @param bVec       numeric vector, used for product
#' @return vector
getCrossprodGRM <- function(bVec) {
    .Call('_TAPE_getCrossprodGRM', PACKAGE = 'TAPE', bVec)
}

#' Get product of GRM and vector (LOCO)
#' 
#' @param bVec       numeric vector, used for product
#' @return vector
getCrossprodGRM_LOCO <- function(bVec) {
    .Call('_TAPE_getCrossprodGRM_LOCO', PACKAGE = 'TAPE', bVec)
}

#' Get product of Sigma and vector
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' 
#' @param bVec       numeric vector, used for product
#' @param sparsekin  matrix of kinship coefficients (sparse).
#' @param W          numeric vector.
#' @param tau        numeric vector, initial values for variance components.
#' @return vector
getCrossprodSig <- function(bVec, sparsekin, W, tau) {
    .Call('_TAPE_getCrossprodSig', PACKAGE = 'TAPE', bVec, sparsekin, W, tau)
}

#' Get product of Sigma and vector
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' 
#' @param bVec       numeric vector, used for product
#' @param sparsekin  matrix of kinship coefficients (sparse).
#' @param W          numeric vector.
#' @param tau        numeric vector, initial values for variance components.
#' @return vector
getCrossprodSig_LOCO <- function(bVec, sparsekin, W, tau) {
    .Call('_TAPE_getCrossprodSig_LOCO', PACKAGE = 'TAPE', bVec, sparsekin, W, tau)
}

#' Get product of Sigma and vector
#' without sparse kinship matrix
#' Sigma = tau[0] * diag(1/W) + tau[1] * grm 
#' 
#' @param bVec       numeric vector, used for product
#' @param W          numeric vector.
#' @param tau        numeric vector, initial values for variance components.
#' @return vector
getCrossprodSig_nok <- function(bVec, W, tau) {
    .Call('_TAPE_getCrossprodSig_nok', PACKAGE = 'TAPE', bVec, W, tau)
}

#' Preconditioned conjugate gradient method (from cPCG)
#'
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' @title Solve for x in Sigma x = b using preconditioned conjugate gradient method.
#' @param sparsekin        matrix of kinship coefficients (sparse).
#' @param W                numeric vector.
#' @param tau              numeric vector, initial values for variance components.
#' @param b                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A vector representing solution x.
pcgsolve_plink <- function(sparsekin, W, tau, b, preconditioner, tol, maxIter) {
    .Call('_TAPE_pcgsolve_plink', PACKAGE = 'TAPE', sparsekin, W, tau, b, preconditioner, tol, maxIter)
}

#' Preconditioned conjugate gradient method LOCO (from cPCG)
#'
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' @title Solve for x in Sigma x = b using preconditioned conjugate gradient method.
#' @param sparsekin        matrix of kinship coefficients (sparse).
#' @param W                numeric vector.
#' @param tau              numeric vector, initial values for variance components.
#' @param b                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A vector representing solution x.
pcgsolve_plink_LOCO <- function(sparsekin, W, tau, b, preconditioner, tol, maxIter) {
    .Call('_TAPE_pcgsolve_plink_LOCO', PACKAGE = 'TAPE', sparsekin, W, tau, b, preconditioner, tol, maxIter)
}

#' Preconditioned conjugate gradient method (from cPCG)
#' without sparse kinship matrix
#'
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' @title Solve for x in Sigma x = b using preconditioned conjugate gradient method.
#' @param W                numeric vector.
#' @param tau              numeric vector, initial values for variance components.
#' @param b                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A vector representing solution x.
pcgsolve_plink_nok <- function(W, tau, b, preconditioner, tol, maxIter) {
    .Call('_TAPE_pcgsolve_plink_nok', PACKAGE = 'TAPE', W, tau, b, preconditioner, tol, maxIter)
}

#' Preconditioned conjugate gradient method (from cPCG)
#'
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' @title Solve for x in Sigma x = B (matrix) using preconditioned conjugate gradient method.
#' @param sparsekin        matrix of kinship coefficients (sparse).
#' @param W                numeric vector.
#' @param tau              numeric vector, initial values for variance components.
#' @param bMat                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A matrix representing solution Sigma_iB.
pcgsolveMat_plink <- function(sparsekin, W, tau, bMat, preconditioner, tol, maxIter) {
    .Call('_TAPE_pcgsolveMat_plink', PACKAGE = 'TAPE', sparsekin, W, tau, bMat, preconditioner, tol, maxIter)
}

#' Preconditioned conjugate gradient method (from cPCG)
#' without sparse kinship matrix
#'
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' @title Solve for x in Sigma x = B (matrix) using preconditioned conjugate gradient method.
#' @param W                numeric vector.
#' @param tau              numeric vector, initial values for variance components.
#' @param bMat                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A matrix representing solution Sigma_iB.
pcgsolveMat_plink_nok <- function(W, tau, bMat, preconditioner, tol, maxIter) {
    .Call('_TAPE_pcgsolveMat_plink_nok', PACKAGE = 'TAPE', W, tau, bMat, preconditioner, tol, maxIter)
}

#' Preconditioned conjugate gradient method LOCO (from cPCG)
#'
#' Sigma = tau[0] * diag(1/W) + tau[1] * sparsekin + tau[2] * grm 
#' @title Solve for x in Sigma x = B (matrix) using preconditioned conjugate gradient method.
#' @param sparsekin        matrix of kinship coefficients (sparse).
#' @param W                numeric vector.
#' @param tau              numeric vector, initial values for variance components.
#' @param bMat                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A matrix representing solution Sigma_iB.
pcgsolveMat_plink_LOCO <- function(sparsekin, W, tau, bMat, preconditioner, tol, maxIter) {
    .Call('_TAPE_pcgsolveMat_plink_LOCO', PACKAGE = 'TAPE', sparsekin, W, tau, bMat, preconditioner, tol, maxIter)
}

#' Get trace using Hutchinson’s randomized trace estimator
#' @param n_nomissing	integer
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param W      numeric vector.
#' @param tau      numeric vector, initial values for variance components.
#' @param Sigma_iX 	matrix
#' @param XSiX_inv 	matrix, covariance
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
getTrace_plink <- function(n_nomissing, q, sparsekin, W, tau, Sigma_iX, XSiX_inv, nrun_trace, maxiter_pcg, tol_pcg, cutoff_trace) {
    .Call('_TAPE_getTrace_plink', PACKAGE = 'TAPE', n_nomissing, q, sparsekin, W, tau, Sigma_iX, XSiX_inv, nrun_trace, maxiter_pcg, tol_pcg, cutoff_trace)
}

#' Get trace using Hutchinson’s randomized trace estimator
#' without sparse kinship matrix
#' @param n_nomissing	integer
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param W      numeric vector.
#' @param tau      numeric vector, initial values for variance components.
#' @param Sigma_iX 	matrix
#' @param XSiX_inv 	matrix, covariance
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
getTrace_plink_nok <- function(n_nomissing, q, W, tau, Sigma_iX, XSiX_inv, nrun_trace, maxiter_pcg, tol_pcg, cutoff_trace) {
    .Call('_TAPE_getTrace_plink_nok', PACKAGE = 'TAPE', n_nomissing, q, W, tau, Sigma_iX, XSiX_inv, nrun_trace, maxiter_pcg, tol_pcg, cutoff_trace)
}

#' Get score within a variance component estimation iteration
#'
#' @title Get score value in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param W 			numeric vector.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param is_AI        boolean. Whether AI trace estimation will be used.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A list with following elements:
#' * YPAPY
#' * Trace
#' * PY
#' * AI
#' * cov = XSiX_inv
#' * tau
#' * alpha
#' * dtau
#' * eta
#' * XSiX_inv_SiXt
getScore_plink <- function(n_nomissing, q, Y, X, sparsekin, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_getScore_plink', PACKAGE = 'TAPE', n_nomissing, q, Y, X, sparsekin, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Get score within a variance component estimation iteration
#' without sparse kinship matrix
#' 
#' @title Get score value in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param W 			numeric vector.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param is_AI        boolean. Whether AI trace estimation will be used.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A list with following elements:
#' * YPAPY
#' * Trace
#' * PY
#' * AI
#' * cov = XSiX_inv
#' * tau
#' * alpha
#' * dtau
#' * eta
#' * XSiX_inv_SiXt
getScore_plink_nok <- function(n_nomissing, q, Y, X, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_getScore_plink_nok', PACKAGE = 'TAPE', n_nomissing, q, Y, X, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Get score within a variance component estimation iteration
#'
#' @title Get score value in GLMM
#' @param n_nomissing	integer, number of non-missing individuals as returned from setgeno()
#' @param q			integer, total number of sparse and dense correlation matrices
#' @param Y			column vector, working y.
#' @param X   			data matrix.
#' @param sparsekin 	matrix of kinship coefficients (sparse).
#' @param W 			numeric vector.
#' @param tau 			numeric vector, initial values for variance components.
#' @param fixtau 		vector with elements 0/1, indicator for whether tau elements are fixed.
#' @param is_AI        boolean. Whether AI trace estimation will be used.
#' @param tol_pcg     	Numeric. Tolerance for the PCG algorithm.
#' @param maxiter_pcg 	Integer. Max number of iterations for the PCG algorithm.
#' @param nrun_trace  	Integer. Number of random vectors used for trace estimation.
#' @param cutoff_trace Numeric. Threshold for the coefficient of variation for trace estimation.
#' @return A list with following elements:
#' * YPAPY
#' * Trace
#' * PY
#' * AI
#' * cov = XSiX_inv
#' * tau
#' * alpha
#' * dtau
#' * eta
#' * XSiX_inv_SiXt
getScore_plink_LOCO <- function(n_nomissing, q, Y, X, sparsekin, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace) {
    .Call('_TAPE_getScore_plink_LOCO', PACKAGE = 'TAPE', n_nomissing, q, Y, X, sparsekin, W, tau, fixtau, is_AI, tol_pcg, maxiter_pcg, nrun_trace, cutoff_trace)
}

#' Get standardized genotype for a given index
#'
#' @param i	integer, index of the genotype to be extracted
#' @return A vector of standardized genotypes for Nnomissing individuals
getOneSNPR <- function(i) {
    .Call('_TAPE_getOneSNPR', PACKAGE = 'TAPE', i)
}

#' Get unstandardized genotype for a given index
#'
#' @param i	integer, index of the genotype to be extracted
#' @return A vector of standardized genotypes for Nnomissing individuals
getOneSNPR_nostd <- function(i) {
    .Call('_TAPE_getOneSNPR_nostd', PACKAGE = 'TAPE', i)
}

icc <- function(A) {
    .Call('_TAPE_icc', PACKAGE = 'TAPE', A)
}

#' Preconditioned conjugate gradient method (from cPCG)
#'
#' Preconditioned conjugate gradient method for solving system of linear equations Ax = b,
#' where A is symmetric and positive definite.
#'
#' @title Solve for x in Ax = b using preconditioned conjugate gradient method.
#' @param A                matrix, symmetric and positive definite.
#' @param b                vector, with same dimension as number of rows of A.
#' @param preconditioner   string, method for preconditioning: \code{"Jacobi"} (default), \code{"SSOR"}, or \code{"ICC"}.
#' @param tol              numeric, threshold for convergence, default is \code{1e-6}.
#' @param maxIter          numeric, maximum iteration, default is \code{1000}.
#' @return A vector representing solution x.
pcgsolve <- function(A, b, preconditioner = "Jacobi", tol = 1e-6, maxIter = 1000L) {
    .Call('_TAPE_pcgsolve', PACKAGE = 'TAPE', A, b, preconditioner, tol, maxIter)
}

readMat <- function(filename, delimeter = "\t") {
    .Call('_TAPE_readMat', PACKAGE = 'TAPE', filename, delimeter)
}

